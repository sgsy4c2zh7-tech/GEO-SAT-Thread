<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GEO Space Weather Dashboard（NOAA APIフルスペックKp推定：Newell結合関数）</title>
  <style>
    body{
      margin:0; padding:16px;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:#111820; color:#f5f5f5;
      display:flex; flex-direction:column; gap:16px;
    }
    h1{font-size:20px;margin:0 0 8px}
    h2{font-size:16px;margin:8px 0}
    .layout{
      display:grid;
      grid-template-columns: 520px minmax(420px,1fr);
      gap:16px;
      align-items:start;
    }
    .card{
      background:#1a2330;
      border-radius:10px;
      padding:12px 14px;
      box-shadow:0 0 0 1px #222c3a;
    }
    #geoCanvas{
      width:100%;
      height:auto;
      background:#141b24;
      border-radius:10px;
      display:block;
    }
    .param-row{
      display:flex; align-items:center; gap:10px;
      margin-bottom:8px; font-size:13px; flex-wrap:wrap;
    }
    .param-row label{flex:0 0 190px}
    .param-row input[type="number"],
    .param-row input[type="range"],
    .param-row input[type="date"]{flex:1}
    .param-row input[type="number"],
    .param-row input[type="date"]{
      max-width:220px;
      padding:4px 6px;
      background:#101621;
      border-radius:6px;
      border:1px solid #303b4c;
      color:#f5f5f5;
    }
    .param-row input[type="range"]{width:100%}
    .time-display{margin-bottom:6px;font-size:14px}
    .badge{
      display:inline-block; padding:3px 10px;
      border-radius:999px; font-size:11px;
      margin-right:8px; line-height:1.4;
      border:1px solid transparent;
    }
    .badge.kp{background:#4caf5022;color:#a5d6a7;border-color:#4caf5055}
    .badge.status{background:#2196f322;color:#90caf9;border-color:#2196f355}
    .badge.noaa{background:#ffffff14;color:#e5e7eb;border-color:#ffffff22}
    .risk-legend,.sector-legend{
      display:flex; gap:10px; flex-wrap:wrap;
      font-size:12px; margin-top:10px; align-items:center;
    }
    .color-box{
      width:14px;height:9px;border-radius:999px;
      border:1px solid #0006; display:inline-block;
      vertical-align:middle; margin-right:6px;
    }
    .small{font-size:11px;opacity:.76}
    .block-title{
      margin-top:12px;
      font-weight:700;
      font-size:13px;
      border-top:1px solid #2a3445;
      padding-top:8px;
    }
    #logicSummary{margin-top:8px;white-space:pre-line}
    .tz-group{display:flex;gap:12px;align-items:center;font-size:12px;flex-wrap:wrap}
    .ok{color:#a5d6a7}
    .ng{color:#ffb3b3}
    .note{font-size:10px;opacity:.65;margin-top:6px}
    @media (max-width:1100px){ .layout{grid-template-columns:1fr} }
  </style>
</head>

<body>
  <h1>GEO Space Weather Dashboard（NOAA API + Newell結合関数でKp推定・フルスペック）</h1>

  <div class="layout">
    <!-- LEFT -->
    <div class="card">
      <h2>Longitude Risk Map</h2>
      <canvas id="geoCanvas" width="520" height="520"></canvas>

      <div class="risk-legend">
        <span><b>Color:</b></span>
        <span><span class="color-box" id="lowColorBox"></span>Low</span>
        <span><span class="color-box" id="medColorBox"></span>Moderate</span>
        <span><span class="color-box" id="highColorBox"></span>High</span>
        <span><span class="color-box" id="extColorBox"></span>Extreme</span>
      </div>

      <div class="sector-legend">
        <span><b>Rings:</b></span>
        <span>Outer = Surface charging</span>
        <span>Inner = Deep charging</span>
      </div>

      <div class="small" style="margin-top:10px;">
        ・青帯は nightside の表示補助（±90° around midnight）。<br>
        ・内部帯電（deep）の放射線帯擾乱は <b>全球一様</b>に評価（昼側も同じ評価に含める）。<br>
        ・表面帯電（surface）は局所時依存を残すが、<b>夜側の過剰ブーストは抑制</b>。
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <h2>Time & Status</h2>

      <div class="time-display">
        <div id="baseTimeLabel"></div>
        <div style="margin-top:6px;">
          Time (UTC): <span id="timeUtcLabel"></span><br>
          <span class="badge kp">Kp̂(t): <span id="kpNowLabel"></span></span>
          <span class="badge status" id="statusLabel"></span>
          <span class="badge noaa" id="noaaBadge"></span>
        </div>
        <div id="logicSummary" class="small"></div>
      </div>

      <input type="range" id="timeSlider" min="0" max="120" step="1" value="0" />

      <div class="block-title">Forecast start time</div>
      <div class="param-row">
        <label for="startDateInput">Start date</label>
        <input type="date" id="startDateInput" />
      </div>
      <div class="param-row">
        <label for="startHourInput">Start hour</label>
        <input type="number" id="startHourInput" min="0" max="23" step="1" value="9" />
      </div>
      <div class="param-row">
        <label>Time zone（入力）</label>
        <div class="tz-group">
          <label><input type="radio" name="tzMode" id="tzJST" value="JST" checked /> JST</label>
          <label><input type="radio" name="tzMode" id="tzUTC" value="UTC" /> UTC</label>
        </div>
        <span class="small">表示は常にUTC。開始時刻をJST/UTCで入力。</span>
      </div>

      <div class="block-title">NOAA API（フルスペック）</div>
      <div class="param-row">
        <label for="useNoaaCheckbox">Use NOAA API</label>
        <input type="checkbox" id="useNoaaCheckbox" checked />
        <span class="small">v,n,By,Bz を取得して Kp̂ を計算（Newell）</span>
      </div>
      <div class="param-row">
        <label for="noaaRefreshMin">API更新間隔（分）</label>
        <input type="number" id="noaaRefreshMin" value="5" min="1" max="60" step="1" />
        <span class="small">GitHub PagesでもOK</span>
      </div>

      <div class="block-title">Kp̂（Newell結合関数）設定</div>
      <div class="param-row">
        <label for="lagMinInput">応答遅れ（分）</label>
        <input type="number" id="lagMinInput" value="45" min="0" max="180" step="5" />
        <span class="small">太陽風→地磁気の遅れ（簡易）</span>
      </div>
      <div class="param-row">
        <label for="smoothHInput">平滑化（時間窓h）</label>
        <input type="number" id="smoothHInput" value="3" min="0" max="12" step="1" />
        <span class="small">移動平均（重くてもOK仕様）</span>
      </div>
      <div class="param-row">
        <label for="alphaInput">動圧補正指数 α</label>
        <input type="number" id="alphaInput" value="0.15" min="0" max="0.6" step="0.05" />
        <span class="small">Pdyn^(α) を掛ける</span>
      </div>
      <div class="param-row">
        <label for="aInput">写像係数 a</label>
        <input type="number" id="aInput" value="2.5" min="0.5" max="6" step="0.1" />
        <span class="small">Kp̂ = a ln(1+Cp)+b</span>
      </div>
      <div class="param-row">
        <label for="bInput">写像係数 b</label>
        <input type="number" id="bInput" value="1.0" min="-2" max="4" step="0.1" />
      </div>
      <div class="param-row">
        <label for="kpStormThresh">storm閾値（Kp̂）</label>
        <input type="number" id="kpStormThresh" value="4.0" min="2" max="7" step="0.1" />
        <span class="small">stormActive 判定</span>
      </div>

      <div class="block-title">Fallback（NOAA欠損/未来補完）</div>
      <div class="param-row">
        <label for="bzInput">Fallback Bz (nT)</label>
        <input type="number" id="bzInput" value="0" step="1" />
        <span class="small">NOAAが無い時だけ使用</span>
      </div>
      <div class="param-row">
        <label for="vswInput">Fallback Vsw (km/s)</label>
        <input type="number" id="vswInput" value="400" step="10" />
      </div>
      <div class="param-row">
        <label for="nAmbInput">Fallback density (cm⁻³)</label>
        <input type="number" id="nAmbInput" value="5" step="0.5" />
      </div>

      <div class="block-title">CME/HSS（未来補完・任意）</div>
      <div class="param-row"><label for="cmeEtaInput">CME ETA (h)</label><input type="number" id="cmeEtaInput" value="-1" step="1" min="-1" max="120" /></div>
      <div class="param-row"><label for="cmeSpeedInput">CME speed</label><input type="number" id="cmeSpeedInput" value="800" step="20" /></div>
      <div class="param-row"><label for="cmeDensityInput">CME density</label><input type="number" id="cmeDensityInput" value="15" step="1" /></div>
      <div class="param-row"><label for="cmeDurInput">CME duration (h)</label><input type="number" id="cmeDurInput" value="6" step="1" min="1" max="24" /></div>

      <div class="param-row"><label for="hssEtaInput">HSS ETA (h)</label><input type="number" id="hssEtaInput" value="-1" step="1" min="-1" max="120" /></div>
      <div class="param-row"><label for="hssSpeedInput">HSS speed</label><input type="number" id="hssSpeedInput" value="700" step="20" /></div>
      <div class="param-row"><label for="hssDensityInput">HSS density</label><input type="number" id="hssDensityInput" value="5" step="0.5" /></div>
      <div class="param-row"><label for="hssDurInput">HSS duration (h)</label><input type="number" id="hssDurInput" value="72" step="6" min="12" max="120" /></div>

      <div class="block-title">Storm/Radiation（リスク側）</div>
      <div class="param-row">
        <label for="quietKpInput">Quiet Kp（基準）</label>
        <input type="number" id="quietKpInput" value="2" step="0.5" min="0" max="5" />
      </div>
      <div class="param-row">
        <label for="dstInput">Dst (nT,参考)</label>
        <input type="number" id="dstInput" value="0" step="10" />
      </div>

      <div class="block-title">Color</div>
      <div class="param-row"><label for="lowColor">Low</label><input type="color" id="lowColor" value="#2ecc71" /></div>
      <div class="param-row"><label for="medColor">Moderate</label><input type="color" id="medColor" value="#f1c40f" /></div>
      <div class="param-row"><label for="highColor">High</label><input type="color" id="highColor" value="#e67e22" /></div>
      <div class="param-row"><label for="extColor">Extreme</label><input type="color" id="extColor" value="#e74c3c" /></div>

      <div class="block-title">Direct impact（任意）</div>
      <div class="param-row">
        <label for="directImpactCheckbox">Direct CME/HSS impact</label>
        <input type="checkbox" id="directImpactCheckbox" />
        <span class="small">短時間の圧縮効果をリスクに直接加算</span>
      </div>

      <div class="note">
        ※Kp̂は「太陽風 v,n,By,Bz → Newell結合関数 → 動圧補正 → 非線形写像」で毎時0–120hを計算。<br>
        ※NOAA欠損・未来はCME/HSS+fallbackで補完（フルスペックでも動く設計）。
      </div>
    </div>
  </div>

<script>
  // ===== DOM =====
  const baseTimeLabel = document.getElementById("baseTimeLabel");
  const timeUtcLabel = document.getElementById("timeUtcLabel");
  const timeSlider = document.getElementById("timeSlider");
  const kpNowLabel = document.getElementById("kpNowLabel");
  const statusLabel = document.getElementById("statusLabel");
  const logicSummary = document.getElementById("logicSummary");
  const noaaBadge = document.getElementById("noaaBadge");

  const startDateInput = document.getElementById("startDateInput");
  const startHourInput = document.getElementById("startHourInput");
  const tzJST = document.getElementById("tzJST");
  const tzUTC = document.getElementById("tzUTC");

  const useNoaaCheckbox = document.getElementById("useNoaaCheckbox");
  const noaaRefreshMin = document.getElementById("noaaRefreshMin");

  const lagMinInput = document.getElementById("lagMinInput");
  const smoothHInput = document.getElementById("smoothHInput");
  const alphaInput = document.getElementById("alphaInput");
  const aInput = document.getElementById("aInput");
  const bInput = document.getElementById("bInput");
  const kpStormThresh = document.getElementById("kpStormThresh");

  const bzInput = document.getElementById("bzInput");
  const vswInput = document.getElementById("vswInput");
  const nAmbInput = document.getElementById("nAmbInput");

  const cmeEtaInput = document.getElementById("cmeEtaInput");
  const cmeSpeedInput = document.getElementById("cmeSpeedInput");
  const cmeDensityInput = document.getElementById("cmeDensityInput");
  const cmeDurInput = document.getElementById("cmeDurInput");

  const hssEtaInput = document.getElementById("hssEtaInput");
  const hssSpeedInput = document.getElementById("hssSpeedInput");
  const hssDensityInput = document.getElementById("hssDensityInput");
  const hssDurInput = document.getElementById("hssDurInput");

  const quietKpInput = document.getElementById("quietKpInput");
  const dstInput = document.getElementById("dstInput");
  const directImpactCheckbox = document.getElementById("directImpactCheckbox");

  const lowColorInput = document.getElementById("lowColor");
  const medColorInput = document.getElementById("medColor");
  const highColorInput = document.getElementById("highColor");
  const extColorInput = document.getElementById("extColor");
  const lowColorBox = document.getElementById("lowColorBox");
  const medColorBox = document.getElementById("medColorBox");
  const highColorBox = document.getElementById("highColorBox");
  const extColorBox = document.getElementById("extColorBox");

  // ===== Canvas =====
  const canvas = document.getElementById("geoCanvas");
  const ctx = canvas.getContext("2d");
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  // Enlarged radii for 520x520
  const surfaceOuterR = 220;
  const surfaceInnerR = 185;
  const deepOuterR = 175;
  const deepInnerR = 140;
  const nightRadiusOuter = 160;
  const nightRadiusInner = 135;
  const earthRadius = 70;

  // ===== Init start date =====
  (function initStartDate(){
    const now = new Date();
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth()+1).padStart(2,"0");
    const dd = String(now.getDate()).padStart(2,"0");
    startDateInput.value = `${yyyy}-${mm}-${dd}`;
    startHourInput.value = now.getHours();
  })();

  function getTzMode(){ return tzUTC.checked ? "UTC" : "JST"; }

  function computeBaseTimeUtc(){
    const dateStr = startDateInput.value;
    const base = new Date(dateStr + "T00:00:00Z");
    let hour = Number(startHourInput.value);
    if(!isFinite(hour)) hour = 0;
    hour = Math.max(0, Math.min(23, hour));
    if(getTzMode()==="JST") base.setUTCHours(hour - 9);
    else base.setUTCHours(hour);
    return base;
  }

  function pad2(n){ return String(n).padStart(2,"0"); }
  function formatUtc(ms){
    const d = new Date(ms);
    return `${d.getUTCFullYear()}-${pad2(d.getUTCMonth()+1)}-${pad2(d.getUTCDate())} ${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())} UTC`;
  }
  function getUtcMsAtHoursAhead(h){
    return computeBaseTimeUtc().getTime() + h*3600*1000;
  }

  // ===== Geometry helpers =====
  function degToRad(deg){ return (deg - 90) * Math.PI / 180; }
  function angleDiff(a,b){ return (a - b + 540) % 360 - 180; }

  // Subsolar longitude (simple)
  function getSubsolarLongitude(hoursAhead){
    const t = new Date(getUtcMsAtHoursAhead(hoursAhead));
    const ut = t.getUTCHours() + t.getUTCMinutes()/60 + t.getUTCSeconds()/3600;
    let lon = (ut - 12) * 15; // 12UT ~ 0°
    lon = ((lon % 360) + 360) % 360;
    return lon;
  }

  function getSector(longitudeDeg, hoursAhead){
    const subsolar = getSubsolarLongitude(hoursAhead);
    const diff = angleDiff(longitudeDeg, subsolar);

    if (Math.abs(diff) <= 90) {
      if (Math.abs(diff) <= 30) return { name:"Day-Noon", code:"D_NOON", isNight:false };
      if (diff < -30) return { name:"Day-Morning", code:"D_MORN", isNight:false };
      return { name:"Day-Afternoon", code:"D_AFTER", isNight:false };
    }
    const nightCenter = (subsolar + 180) % 360;
    const diffN = angleDiff(longitudeDeg, nightCenter);
    if (Math.abs(diffN) <= 30) return { name:"Night-Midnight", code:"N_MID", isNight:true };
    if (diffN < -30) return { name:"Night-Evening", code:"N_EVE", isNight:true };
    return { name:"Night-Morning", code:"N_MORN", isNight:true };
  }

  // ===== NOAA store =====
  const noaa = {
    enabled: true,
    plasma: [], // {tMs, density, speed}
    mag: [],    // {tMs, by, bz, bt}
    lastOkMs: null,
    lastErr: null
  };

  function setNoaaBadge(){
    const on = noaa.enabled && useNoaaCheckbox.checked;
    const ok = (noaa.lastOkMs != null);
    if(!on){
      noaaBadge.textContent = "NOAA: OFF";
      noaaBadge.className = "badge noaa ng";
      return;
    }
    if(ok){
      noaaBadge.textContent = `NOAA: ON / last ${new Date(noaa.lastOkMs).toISOString().slice(11,16)}Z`;
      noaaBadge.className = "badge noaa ok";
    }else{
      noaaBadge.textContent = `NOAA: ON / (no data)`;
      noaaBadge.className = "badge noaa ng";
    }
  }

  async function fetchJsonNoStore(url){
    const res = await fetch(url + (url.includes("?") ? "&" : "?") + "_=" + Date.now(), { cache:"no-store" });
    if(!res.ok) throw new Error(`fetch failed ${res.status}`);
    return res.json();
  }

  async function fetchNoaaPlasma(){
    // 2-hour product, includes density & speed
    const url = "https://services.swpc.noaa.gov/products/solar-wind/plasma-2-hour.json";
    const data = await fetchJsonNoStore(url);
    if(!Array.isArray(data) || data.length < 2) return [];
    const rows = data.slice(1);
    const out = [];
    for(const r of rows){
      const tMs = Date.parse(String(r[0]).replace(" ","T")+"Z");
      const density = (r[1]==null) ? null : Number(r[1]);
      const speed   = (r[2]==null) ? null : Number(r[2]);
      if(isFinite(tMs)) out.push({ tMs, density, speed });
    }
    out.sort((a,b)=>a.tMs-b.tMs);
    return out;
  }

  async function fetchNoaaMag(){
    // 2-hour mag: By,Bz,Bt
    const url = "https://services.swpc.noaa.gov/products/solar-wind/mag-2-hour.json";
    const data = await fetchJsonNoStore(url);
    if(!Array.isArray(data) || data.length < 2) return [];
    const rows = data.slice(1);
    const out = [];
    for(const r of rows){
      const tMs = Date.parse(String(r[0]).replace(" ","T")+"Z");
      // Typical columns: time_tag, bx_gsm, by_gsm, bz_gsm, bt
      // We'll be defensive: try indices [2]=By, [3]=Bz, [4]=Bt as common in SWPC JSON.
      const by = (r[2]==null) ? null : Number(r[2]);
      const bz = (r[3]==null) ? null : Number(r[3]);
      const bt = (r[4]==null) ? null : Number(r[4]);
      if(isFinite(tMs)) out.push({ tMs, by, bz, bt });
    }
    out.sort((a,b)=>a.tMs-b.tMs);
    return out;
  }

  async function refreshNoaa(){
    if(!(useNoaaCheckbox.checked)) return;
    noaa.enabled = true;
    try{
      const [plasma, mag] = await Promise.all([fetchNoaaPlasma(), fetchNoaaMag()]);
      noaa.plasma = plasma;
      noaa.mag = mag;
      noaa.lastOkMs = Date.now();
      noaa.lastErr = null;
    }catch(e){
      noaa.lastErr = String(e?.message || e);
      // keep old data (best effort)
    }finally{
      setNoaaBadge();
    }
  }

  // ===== Interpolation helpers =====
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function lerp(a,b,t){ return a + (b-a)*t; }

  function interpLinear(series, tMs, key){
    if(!series || series.length === 0) return null;
    // binary search rightmost <= tMs
    let lo=0, hi=series.length-1;
    while(lo<hi){
      const mid = (lo+hi+1)>>1;
      if(series[mid].tMs <= tMs) lo=mid;
      else hi=mid-1;
    }
    const p0 = series[lo];
    const p1 = series[Math.min(series.length-1, lo+1)];
    const v0 = p0 ? p0[key] : null;
    const v1 = p1 ? p1[key] : null;
    if(!isFinite(v0)) return (isFinite(v1) ? v1 : null);
    if(p0.tMs === p1.tMs || !isFinite(v1)) return v0;
    const t = (tMs - p0.tMs) / (p1.tMs - p0.tMs);
    return lerp(v0, v1, clamp(t,0,1));
  }

  // ===== CME/HSS windows (fallback future) =====
  function isHssActive(t){
    const eta = Number(hssEtaInput.value);
    const dur = Number(hssDurInput.value);
    if(eta < 0) return false;
    return t >= eta && t <= (eta + dur);
  }
  function isCmeImpact(t){
    const eta = Number(cmeEtaInput.value);
    const dur = Number(cmeDurInput.value);
    if(eta < 0) return false;
    const half = dur/2;
    return t >= (eta - half) && t <= (eta + half);
  }

  function fallbackSolarWindSpeedAt(t){
    const vswAmb = Number(vswInput.value);
    const cmeSpeed = Number(cmeSpeedInput.value);
    const hssSpeed = Number(hssSpeedInput.value);
    if(isCmeImpact(t)) return cmeSpeed;
    if(isHssActive(t)) return hssSpeed;
    return vswAmb;
  }
  function fallbackSolarWindDensityAt(t){
    const nAmb = Number(nAmbInput.value);
    const cmeD = Number(cmeDensityInput.value);
    const hssD = Number(hssDensityInput.value);
    if(isCmeImpact(t)) return cmeD;
    if(isHssActive(t)) return hssD;
    return nAmb;
  }

  // ===== Full-spec solar wind getters (NOAA + fallback) =====
  function getVAtHours(h){
    const tMs = getUtcMsAtHoursAhead(h);
    if(useNoaaCheckbox.checked){
      const v = interpLinear(noaa.plasma, tMs, "speed");
      if(isFinite(v)) return v;
    }
    return fallbackSolarWindSpeedAt(h);
  }
  function getNAtHours(h){
    const tMs = getUtcMsAtHoursAhead(h);
    if(useNoaaCheckbox.checked){
      const n = interpLinear(noaa.plasma, tMs, "density");
      if(isFinite(n)) return n;
    }
    return fallbackSolarWindDensityAt(h);
  }
  function getByAtHours(h){
    const tMs = getUtcMsAtHoursAhead(h);
    if(useNoaaCheckbox.checked){
      const by = interpLinear(noaa.mag, tMs, "by");
      if(isFinite(by)) return by;
    }
    return 0; // fallback: unknown
  }
  function getBzAtHours(h){
    const tMs = getUtcMsAtHoursAhead(h);
    if(useNoaaCheckbox.checked){
      const bz = interpLinear(noaa.mag, tMs, "bz");
      if(isFinite(bz)) return bz;
    }
    return Number(bzInput.value); // fallback
  }
  function getBtAtHours(h){
    const tMs = getUtcMsAtHoursAhead(h);
    if(useNoaaCheckbox.checked){
      // Some feeds include bt; if missing, compute from By,Bz
      const bt = interpLinear(noaa.mag, tMs, "bt");
      if(isFinite(bt)) return bt;
    }
    const by = getByAtHours(h);
    const bz = getBzAtHours(h);
    const bt = Math.sqrt((by||0)*(by||0) + (bz||0)*(bz||0));
    return bt;
  }

  // ===== Newell coupling (full spec) =====
  function newellCoupling(v, by, bz, bt){
    // C = v^(4/3) * Bt^(2/3) * sin^(8/3)(theta/2)
    // theta = atan2(By, Bz) in GSM
    if(!isFinite(v) || !isFinite(bt)) return 0;

    const By = (isFinite(by) ? by : 0);
    const Bz = (isFinite(bz) ? bz : 0);

    const theta = Math.atan2(By, Bz); // [-pi, pi]
    const sinTerm = Math.sin(theta/2);
    const sinPow = Math.pow(Math.abs(sinTerm), 8/3);

    const vPow = Math.pow(Math.max(0, v), 4/3);
    const btPow = Math.pow(Math.max(0, bt), 2/3);

    const C = vPow * btPow * sinPow;
    return isFinite(C) ? C : 0;
  }

  function pdynIndex(n, v){
    // relative dynamic pressure index (dimensionless)
    // ~ (n/5)*(v/400)^2
    const nRef = 5.0;
    const vRef = 400.0;
    let idx = (n/nRef) * Math.pow(v/vRef, 2);
    if(!isFinite(idx) || idx <= 0) idx = 1.0;
    return clamp(idx, 0.3, 6.0);
  }

  // Normalize coupling so quiet-ish baseline is around 1
  function couplingNorm(C){
    // Reference: v0=400, Bt0=5, theta=pi -> sin(theta/2)=1
    const v0 = 400;
    const bt0 = 5;
    const C0 = Math.pow(v0,4/3) * Math.pow(bt0,2/3) * 1.0;
    if(!isFinite(C0) || C0<=0) return C;
    return C / C0;
  }

  // ===== Kp-hat series (heavy ok) =====
  let kpSeries = new Array(121).fill(2.0);  // kp at each hour 0..120
  let bzSeries = new Array(121).fill(0.0);  // for logic/status
  let vSeries  = new Array(121).fill(400);
  let nSeries  = new Array(121).fill(5);
  let stormActiveSeries = new Array(121).fill(false);

  function movingAverage(arr, win){
    if(win <= 1) return arr.slice();
    const out = new Array(arr.length).fill(0);
    const half = Math.floor(win/2);
    for(let i=0;i<arr.length;i++){
      let sum=0, cnt=0;
      for(let k=-half;k<=half;k++){
        const j=i+k;
        if(j>=0 && j<arr.length){
          sum += arr[j];
          cnt++;
        }
      }
      out[i] = (cnt>0) ? (sum/cnt) : arr[i];
    }
    return out;
  }

  function recomputeKpSeries(){
    const lagMin = Number(lagMinInput.value);
    const alpha = Number(alphaInput.value);
    const a = Number(aInput.value);
    const b = Number(bInput.value);
    const smoothH = Number(smoothHInput.value);

    // Build Cp at each hour (0..120)
    const cp = new Array(121).fill(0);

    for(let h=0; h<=120; h++){
      // Apply lag: use solar wind at (h - lag)
      const lagH = lagMin/60;
      const hs = h - lagH;

      // sample solar wind at fractional hour hs (linear between floor/ceil)
      function sampleAtFrac(getter){
        const h0 = Math.floor(hs);
        const h1 = Math.ceil(hs);
        if(h0 < 0) return getter(0);
        if(h1 > 120) return getter(120);
        if(h0 === h1) return getter(h0);
        const t = hs - h0;
        return lerp(getter(h0), getter(h1), clamp(t,0,1));
      }

      const v = sampleAtFrac(getVAtHours);
      const n = sampleAtFrac(getNAtHours);
      const by = sampleAtFrac(getByAtHours);
      const bz = sampleAtFrac(getBzAtHours);
      const bt = sampleAtFrac(getBtAtHours);

      vSeries[h] = v;
      nSeries[h] = n;
      bzSeries[h] = bz;

      const C = newellCoupling(v, by, bz, bt);
      const Cn = couplingNorm(C);
      const P = pdynIndex(n, v);
      const Cp = Cn * Math.pow(P, clamp(alpha, 0, 1));
      cp[h] = isFinite(Cp) ? Math.max(0, Cp) : 0;
    }

    // Heavy smoothing on Cp (optional)
    const cpSm = (smoothH && smoothH>0) ? movingAverage(cp, Math.max(1, Math.round(smoothH))) : cp;

    // Map to Kp-hat (saturating)
    const kp = new Array(121).fill(0);
    for(let h=0; h<=120; h++){
      const val = a * Math.log(1 + cpSm[h]) + b;
      kp[h] = clamp(val, 0, 9);
    }

    // Optional smoothing on Kp itself (if you want it even heavier)
    const kpSm = (smoothH && smoothH>0) ? movingAverage(kp, Math.max(1, Math.round(smoothH))) : kp;

    kpSeries = kpSm;
    const thr = Number(kpStormThresh.value);
    stormActiveSeries = kpSeries.map(x => x >= thr);
  }

  function kpAtHour(h){
    const i = clamp(Math.round(h), 0, 120);
    return kpSeries[i] ?? 2.0;
  }
  function bzAtHour(h){
    const i = clamp(Math.round(h), 0, 120);
    return bzSeries[i] ?? 0;
  }

  // ===== Radiation belt term (global) =====
  // Define radiation window after storm ends:
  //  - Detect contiguous storm segments (kp>=thr). Use the first segment as main storm.
  //  - radStart = stormEnd + 24h, radEnd = radStart + 48h
  let radWindow = { exists:false, start:0, end:0 };
  function recomputeRadiationWindow(){
    const thr = Number(kpStormThresh.value);
    let inSeg=false, segStart=0, segEnd=0;
    for(let h=0; h<=120; h++){
      const on = (kpSeries[h] >= thr);
      if(on && !inSeg){ inSeg=true; segStart=h; segEnd=h; }
      if(on && inSeg){ segEnd=h; }
      if(!on && inSeg){ break; } // take first segment
    }
    if(inSeg){
      const start = segEnd + 24;
      const end = start + 48;
      if(start <= 120){
        radWindow = { exists:true, start, end: Math.min(120, end) };
        return;
      }
    }
    radWindow = { exists:false, start:0, end:0 };
  }
  function isRadActive(h){
    return radWindow.exists && h >= radWindow.start && h <= radWindow.end;
  }
  function radiationTerm(h){
    if(!isRadActive(h)) return 0;
    const mid = (radWindow.start + radWindow.end)/2;
    const span = Math.max(1e-6, (radWindow.end - radWindow.start)/2);
    const dist = Math.abs(h - mid)/span;
    const shape = Math.max(0, 1 - dist);
    return 3.5 * shape; // amp
  }

  // ===== Global quiet =====
  function isGloballyQuiet(h){
    // Use Kp̂ itself as primary "quiet" gate, plus optional dst
    const kp = kpAtHour(h);
    const dst = Number(dstInput.value);
    const quietByKp = (kp <= 2.0);
    const dstQuiet = (Math.abs(dst) <= 20);
    return quietByKp && dstQuiet;
  }

  // ===== Colors =====
  function getColors(){
    const low = lowColorInput.value || "#2ecc71";
    const med = medColorInput.value || "#f1c40f";
    const high = highColorInput.value || "#e67e22";
    const ext = extColorInput.value || "#e74c3c";
    lowColorBox.style.background = low;
    medColorBox.style.background = med;
    highColorBox.style.background = high;
    extColorBox.style.background = ext;
    return { low, med, high, ext };
  }
  function riskToColor(r){
    const c = getColors();
    if(r < 3) return c.low;
    if(r < 6) return c.med;
    if(r < 8) return c.high;
    return c.ext;
  }

  // ===== Risk model =====
  function computeSurfaceRisk(h, lon){
    if(isGloballyQuiet(h)) return { value:0.5, sector:getSector(lon,h) };

    const sector = getSector(lon,h);
    const quietKp = Number(quietKpInput.value);
    const kp = kpAtHour(h);

    // stormBase: Kp above quiet
    const stormBase = Math.max(0, kp - quietKp);

    // Southward IMF indicator (time-varying if NOAA)
    const bz = bzAtHour(h);
    const bzTerm = (bz < 0) ? 1.0 : 0.0;

    // Direct impact (optional): compressions from CME/HSS (fallback windows)
    const directOn = directImpactCheckbox.checked;
    let direct = 0;
    if(directOn){
      if(isCmeImpact(h)) direct += 0.9;
      if(isHssActive(h)) direct += 0.4;
    }

    // LT weights (night boost moderated)
    let stormMult=1.0, bzMult=1.0, offset=0.4;
    switch(sector.code){
      case "D_MORN": stormMult=0.55; bzMult=0.65; offset=0.25; break;
      case "D_NOON": stormMult=0.45; bzMult=0.60; offset=0.22; break;
      case "D_AFTER":stormMult=0.60; bzMult=0.75; offset=0.30; break;
      case "N_EVE":  stormMult=1.10; bzMult=1.15; offset=0.60; break;
      case "N_MID":  stormMult=1.25; bzMult=1.25; offset=0.70; break;
      case "N_MORN": stormMult=1.05; bzMult=1.10; offset=0.58; break;
    }

    let risk = stormBase*stormMult + bzTerm*bzMult + offset + direct;
    // clamp
    risk = clamp(risk, 0, 10);
    return { value:risk, sector };
  }

  function computeDeepRisk(h, lon){
    if(isGloballyQuiet(h)) return { value:0.5, sector:getSector(lon,h) };

    const sector = getSector(lon,h);
    const quietKp = Number(quietKpInput.value);
    const kp = kpAtHour(h);

    const stormBase = Math.max(0, kp - quietKp);
    const rad = radiationTerm(h); // global

    // Bz term is weaker for deep (it's mainly radiation belts + prolonged activity)
    const bz = bzAtHour(h);
    const bzTerm = (bz < 0) ? 0.6 : 0.0;

    const directOn = directImpactCheckbox.checked;
    let direct = 0;
    if(directOn){
      if(isCmeImpact(h)) direct += 0.35;
      if(isHssActive(h)) direct += 0.20;
    }

    // LT dependence minimized (no nightside boost)
    const offset = 0.45;
    let risk = stormBase*0.95 + rad*1.0 + bzTerm + offset + direct;

    // If radiation active, deep risk should not depend on night/day (already global)
    risk = clamp(risk, 0, 10);
    return { value:risk, sector };
  }

  // ===== Drawing =====
  function drawGeoRings(){
    const h = Number(timeSlider.value);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "#141b24";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const step = 10;
    for(let lon=0; lon<360; lon+=step){
      const mid = lon + step/2;

      const s = computeSurfaceRisk(h, mid).value;
      const d = computeDeepRisk(h, mid).value;

      const sCol = riskToColor(s);
      const dCol = riskToColor(d);

      const a0 = degToRad(lon);
      const a1 = degToRad(lon + step);

      // Surface ring
      ctx.beginPath();
      ctx.arc(cx, cy, surfaceOuterR, a0, a1, false);
      ctx.arc(cx, cy, surfaceInnerR, a1, a0, true);
      ctx.closePath();
      ctx.fillStyle = sCol;
      ctx.fill();

      // Deep ring
      ctx.beginPath();
      ctx.arc(cx, cy, deepOuterR, a0, a1, false);
      ctx.arc(cx, cy, deepInnerR, a1, a0, true);
      ctx.closePath();
      ctx.fillStyle = dCol;
      ctx.fill();
    }

    // Nightside band (visual aid only)
    const sub = getSubsolarLongitude(h);
    const nightCenter = (sub + 180) % 360;
    const ns = nightCenter - 90;
    const ne = nightCenter + 90;

    ctx.beginPath();
    ctx.arc(cx, cy, nightRadiusOuter, degToRad(ns), degToRad(ne), false);
    ctx.arc(cx, cy, nightRadiusInner, degToRad(ne), degToRad(ns), true);
    ctx.closePath();
    ctx.fillStyle = "rgba(52,93,255,0.35)";
    ctx.fill();

    // Earth
    ctx.beginPath();
    ctx.arc(cx, cy, earthRadius, 0, Math.PI*2);
    ctx.fillStyle = "#0f1724";
    ctx.fill();
    ctx.strokeStyle = "#324055";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Longitude labels
    ctx.fillStyle = "#f5f5f5";
    ctx.font = "11px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for(let lon=0; lon<360; lon+=30){
      const ang = degToRad(lon);
      const r = surfaceOuterR + 18;
      ctx.fillText(String(lon), cx + r*Math.cos(ang), cy + r*Math.sin(ang));
    }

    // Center label
    ctx.fillStyle = "#f5f5f5";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "bold 14px system-ui";
    ctx.fillText("Surface / Deep Charging Risk", cx, cy - 14);
    ctx.font = "11px system-ui";
    const utcZ = new Date(getUtcMsAtHoursAhead(h)).toISOString().slice(0,16).replace("T"," ") + "Z";
    ctx.fillText(utcZ, cx, cy + 10);
  }

  // ===== Labels =====
  function updateLabels(){
    const h = Number(timeSlider.value);
    const baseUtc = computeBaseTimeUtc();

    baseTimeLabel.textContent = `Forecast start: ${formatUtc(baseUtc.getTime())}`;
    const tMs = getUtcMsAtHoursAhead(h);
    timeUtcLabel.textContent = formatUtc(tMs);

    const kp = kpAtHour(h);
    kpNowLabel.textContent = kp.toFixed(2);

    const parts = [];
    const thr = Number(kpStormThresh.value);
    if(kp >= thr) parts.push("Geomagnetic storm (by Kp̂)");
    if(isRadActive(h)) parts.push("Radiation belt disturbance (global)");
    if(isCmeImpact(h)) parts.push("CME (fallback window)");
    if(isHssActive(h)) parts.push("HSS (fallback window)");
    statusLabel.textContent = parts.length ? parts.join(" + ") : "Quiet";

    const v = vSeries[Math.round(h)] ?? getVAtHours(h);
    const n = nSeries[Math.round(h)] ?? getNAtHours(h);
    const bz = bzAtHour(h);
    const alpha = Number(alphaInput.value);
    const lagMin = Number(lagMinInput.value);
    const smoothH = Number(smoothHInput.value);

    const globalQuiet = isGloballyQuiet(h);

    logicSummary.textContent =
`現在（UTC=${formatUtc(tMs)}）
 - NOAA API: ${useNoaaCheckbox.checked ? "ON" : "OFF"} / lastOK=${noaa.lastOkMs ? new Date(noaa.lastOkMs).toISOString().slice(11,16)+"Z" : "--"}${noaa.lastErr ? " / err="+noaa.lastErr : ""}
 - v=${v.toFixed(0)} km/s, n=${n.toFixed(1)} cm⁻³, Bz=${isFinite(bz)?bz.toFixed(2):"--"} nT
 - Kp̂=${kp.toFixed(2)}（Newell + Pdyn^α, lag=${lagMin}min, smooth=${smoothH}h, α=${alpha.toFixed(2)}）
 - stormThreshold=${thr.toFixed(1)} / radWindow=${radWindow.exists ? (radWindow.start.toFixed(0)+"–"+radWindow.end.toFixed(0)+"h") : "none"}
 - globalQuiet=${globalQuiet ? "YES (low forced)" : "NO"}`;
  }

  // ===== Update pipeline =====
  function updateAll(){
    // heavy part first
    recomputeKpSeries();
    recomputeRadiationWindow();

    setNoaaBadge();
    updateLabels();
    getColors();
    drawGeoRings();
  }

  // ===== Events =====
  function hookInputs(){
    const els = [
      startDateInput, startHourInput, tzJST, tzUTC,
      useNoaaCheckbox, noaaRefreshMin,
      lagMinInput, smoothHInput, alphaInput, aInput, bInput, kpStormThresh,
      bzInput, vswInput, nAmbInput,
      cmeEtaInput, cmeSpeedInput, cmeDensityInput, cmeDurInput,
      hssEtaInput, hssSpeedInput, hssDensityInput, hssDurInput,
      quietKpInput, dstInput,
      lowColorInput, medColorInput, highColorInput, extColorInput,
      directImpactCheckbox
    ];
    els.forEach(el => el.addEventListener("input", () => updateAll()));
    useNoaaCheckbox.addEventListener("change", async () => { await refreshNoaa(); updateAll(); });
    timeSlider.addEventListener("input", () => updateAll());
  }
  hookInputs();

  // ===== Scheduler =====
  let refreshTimer = null;
  function startRefreshLoop(){
    if(refreshTimer) clearInterval(refreshTimer);
    const min = clamp(Number(noaaRefreshMin.value)||5, 1, 60);
    refreshTimer = setInterval(async ()=>{
      await refreshNoaa();
      updateAll();
    }, min*60*1000);
  }
  noaaRefreshMin.addEventListener("input", startRefreshLoop);

  // ===== Boot =====
  (async function boot(){
    await refreshNoaa();
    startRefreshLoop();
    updateAll();
  })();
</script>
</body>
</html>
